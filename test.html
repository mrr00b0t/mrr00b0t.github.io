<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speed Test - Internet Broadband Testing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: #ffffff;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.4) 0%, transparent 60%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.4) 0%, transparent 60%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.4) 0%, transparent 60%);
            z-index: -1;
            animation: gradientShift 20s ease-in-out infinite;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 60% 30%, rgba(255, 200, 87, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 10% 80%, rgba(87, 255, 200, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 90% 90%, rgba(200, 87, 255, 0.2) 0%, transparent 50%);
            z-index: -1;
            animation: gradientShift 25s ease-in-out infinite reverse;
        }

        @keyframes gradientShift {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-20px, -20px) rotate(1deg); }
            50% { transform: translate(20px, -10px) rotate(-1deg); }
            75% { transform: translate(-10px, 20px) rotate(0.5deg); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(25px) saturate(180%);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.37),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            padding: 35px;
            margin: 25px 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            transition: opacity 0.4s ease;
            opacity: 0;
        }

        .glass-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 
                0 20px 60px rgba(31, 38, 135, 0.6),
                0 5px 20px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .glass-card:hover::before {
            opacity: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(45deg, #fff, #a8edea, #ffd89b);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: gradientText 4s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
        }

        @keyframes gradientText {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        .speed-display {
            text-align: center;
            margin: 40px 0;
        }

        .speed-value {
            font-size: 4rem;
            font-weight: 800;
            background: linear-gradient(45deg, #00f5ff, #ff00d4, #00ff88);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            animation: speedGlow 3s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            position: relative;
        }

        .speed-value::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120%;
            height: 120%;
            background: radial-gradient(circle, rgba(0, 245, 255, 0.2) 0%, transparent 70%);
            z-index: -1;
            border-radius: 50%;
            animation: pulseGlow 2s ease-in-out infinite;
        }

        @keyframes speedGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes pulseGlow {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
        }

        .speed-unit {
            font-size: 1.5rem;
            opacity: 0.7;
            margin-left: 10px;
        }

        .speed-label {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-top: 10px;
        }

        .test-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24, #ff9f43);
            background-size: 200% 200%;
            border: none;
            border-radius: 50px;
            padding: 18px 45px;
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: block;
            margin: 30px auto;
            box-shadow: 
                0 8px 25px rgba(238, 90, 36, 0.4),
                0 2px 10px rgba(255, 107, 107, 0.3);
            position: relative;
            overflow: hidden;
            animation: buttonGradient 3s ease-in-out infinite;
        }

        .test-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .test-button:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 
                0 15px 35px rgba(238, 90, 36, 0.6),
                0 5px 15px rgba(255, 107, 107, 0.4);
            background-size: 150% 150%;
        }

        .test-button:hover::before {
            left: 100%;
        }

        .test-button:disabled {
            background: linear-gradient(45deg, #666, #888);
            cursor: not-allowed;
            transform: none;
            animation: none;
        }

        .test-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        @keyframes buttonGradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(20px) saturate(150%);
            border-radius: 18px;
            padding: 30px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.12);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .metric-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-6px) scale(1.03);
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.2),
                0 5px 15px rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.25);
        }

        .metric-card:hover::before {
            opacity: 1;
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00f5ff, #ff00d4, #00ff88);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: metricGlow 4s ease-in-out infinite;
            transition: all 0.3s ease;
        }

        @keyframes metricGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .metric-label {
            font-size: 1rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .progress-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            height: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, #00f5ff, #ff00d4, #00ff88);
            background-size: 200% 100%;
            height: 100%;
            width: 0%;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 50px;
            animation: progressFlow 2s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressShimmer 1.5s ease-in-out infinite;
        }

        @keyframes progressFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes progressShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .chart-container {
            margin: 30px 0;
            text-align: center;
        }

        .chart-canvas {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-section {
            margin-top: 40px;
        }

        .history-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }

        .history-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-date {
            opacity: 0.7;
            font-size: 0.9rem;
        }

        .history-speed {
            font-weight: 600;
            color: #00f5ff;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            margin: 20px auto;
            position: relative;
        }

        .loading-spinner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-top: 3px solid #00f5ff;
            border-right: 3px solid #ff00d4;
            border-radius: 50%;
            animation: spinGradient 1.2s linear infinite;
        }

        .loading-spinner::after {
            content: '';
            position: absolute;
            top: 6px;
            left: 6px;
            width: calc(100% - 12px);
            height: calc(100% - 12px);
            border: 2px solid transparent;
            border-bottom: 2px solid #00ff88;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: spinGradient 1s linear infinite reverse;
        }

        @keyframes spinGradient {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .particle {
            position: fixed;
            pointer-events: none;
            opacity: 0.7;
            z-index: 0;
        }

        .particle::before {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, transparent 70%);
            border-radius: 50%;
            animation: particleFloat 8s linear infinite;
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.7;
            }
            90% {
                opacity: 0.7;
            }
            100% {
                transform: translateY(-10vh) rotate(360deg);
                opacity: 0;
            }
        }

        .error-message {
            background: rgba(255, 82, 82, 0.2);
            border: 1px solid rgba(255, 82, 82, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            color: #ff5252;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .status-ready {
            background: #4caf50;
        }

        .status-testing {
            background: #ff9800;
            animation: pulse 1s infinite;
        }

        .status-complete {
            background: #2196f3;
        }

        .status-error {
            background: #f44336;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .header h1 {
                font-size: 2.5rem;
            }

            .speed-value {
                font-size: 3rem;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .glass-card {
                padding: 20px;
            }
        }

        .info-tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .info-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            animation: tooltipFade 0.3s ease-out;
        }

        @keyframes tooltipFade {
            from { opacity: 0; transform: translateX(-50%) translateY(5px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Enhanced mobile responsiveness */
        @media (max-width: 480px) {
            .speed-value {
                font-size: 3rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .test-button {
                padding: 15px 35px;
                font-size: 1.1rem;
            }
            
            .glass-card {
                padding: 25px;
                margin: 20px 0;
            }
        }

        /* Smooth scrolling for entire page */
        html {
            scroll-behavior: smooth;
        }

        /* Enhanced status indicators with animations */
        .status-ready {
            background: #4caf50;
            animation: statusPulse 2s ease-in-out infinite;
        }

        .status-testing {
            background: #ff9800;
            animation: statusPulse 1s ease-in-out infinite;
        }

        .status-complete {
            background: #2196f3;
            animation: statusComplete 0.5s ease-out;
        }

        .status-error {
            background: #f44336;
            animation: statusError 0.5s ease-out;
        }

        @keyframes statusPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }

        @keyframes statusComplete {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); }
            100% { transform: scale(1); }
        }

        @keyframes statusError {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Speed Test</h1>
            <p>Test your internet connection speed with precision</p>
        </div>

        <div class="glass-card">
            <div class="speed-display">
                <div class="speed-value" id="speedValue">0.00</div>
                <span class="speed-unit">Mbps</span>
                <div class="speed-label" id="speedLabel">Download Speed</div>
            </div>

            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>

            <button class="test-button" id="testButton" onclick="startSpeedTest()">
                <span class="status-indicator status-ready" id="statusIndicator"></span>
                Start Speed Test
            </button>

            <div class="loading-spinner" id="loadingSpinner" style="display: none;"></div>
            <div class="error-message" id="errorMessage" style="display: none;"></div>
        </div>

        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-value" id="downloadSpeed">0.00</div>
                <div class="metric-label info-tooltip" data-tooltip="Your download speed in Mbps">Download</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="latency">0</div>
                <div class="metric-label info-tooltip" data-tooltip="Round-trip time in milliseconds">Ping (ms)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="jitter">0</div>
                <div class="metric-label info-tooltip" data-tooltip="Variation in latency measurements">Jitter (ms)</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="packetLoss">0</div>
                <div class="metric-label info-tooltip" data-tooltip="Percentage of lost packets">Packet Loss (%)</div>
            </div>
        </div>

        <div class="glass-card">
            <h3 style="text-align: center; margin-bottom: 20px;">Client Information</h3>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="clientIP" style="font-size: 1.2rem;">Loading...</div>
                    <div class="metric-label">IP Address</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="clientISP" style="font-size: 1.2rem;">Loading...</div>
                    <div class="metric-label">ISP Provider</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="clientLocation" style="font-size: 1.2rem;">Loading...</div>
                    <div class="metric-label">Location</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="clientDevice" style="font-size: 1.2rem;">Loading...</div>
                    <div class="metric-label">Device Type</div>
                </div>
            </div>
            <div style="margin-top: 20px; text-align: center; opacity: 0.7; font-size: 0.9rem;">
                <div id="browserInfo">Browser: Loading...</div>
                <div id="connectionInfo">Connection: Loading...</div>
                <div id="screenInfo">Screen: Loading...</div>
            </div>
        </div>

        <div class="glass-card chart-container">
            <h3>Real-time Speed Graph</h3>
            <canvas id="speedChart" class="chart-canvas" width="800" height="300"></canvas>
        </div>

        <div class="glass-card history-section">
            <h3 class="history-title">Test History</h3>
            <div id="historyContainer">
                <p style="text-align: center; opacity: 0.7;">No tests completed yet</p>
            </div>
        </div>
    </div>

    <script>
        // Speed test configuration
        const CONFIG = {
            testDuration: 15000, // 15 seconds
            testServers: [
                'https://proof.ovh.net/files/100Mb.dat',
                'https://speed.cloudflare.com/__down?bytes=100000000',
                'https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png',
                // Fallback to data URLs for consistent testing
                'data:text/plain;base64,' + btoa('x'.repeat(1024 * 1024)) // 1MB of data
            ],
            chunkSize: 1024 * 1024, // 1MB chunks
            maxConcurrentTests: 3
        };

        // Global variables
        let isTestRunning = false;
        let testStartTime = 0;
        let speedData = [];
        let testHistory = JSON.parse(localStorage.getItem('speedTestHistory') || '[]');
        let chart = null;
        let currentTestType = 'download';

        // Initialize chart
        function initChart() {
            const canvas = document.getElementById('speedChart');
            const ctx = canvas.getContext('2d');
            
            chart = {
                canvas: canvas,
                ctx: ctx,
                data: [],
                maxSpeed: 100,
                draw: function() {
                    const width = canvas.width;
                    const height = canvas.height;
                    const padding = 40;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, width, height);
                    
                    // Draw grid
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    
                    // Horizontal grid lines
                    for (let i = 0; i <= 10; i++) {
                        const y = padding + (height - 2 * padding) * i / 10;
                        ctx.beginPath();
                        ctx.moveTo(padding, y);
                        ctx.lineTo(width - padding, y);
                        ctx.stroke();
                    }
                    
                    // Vertical grid lines
                    for (let i = 0; i <= 10; i++) {
                        const x = padding + (width - 2 * padding) * i / 10;
                        ctx.beginPath();
                        ctx.moveTo(x, padding);
                        ctx.lineTo(x, height - padding);
                        ctx.stroke();
                    }
                    
                    // Draw speed line
                    if (this.data.length > 1) {
                        ctx.strokeStyle = '#00f5ff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        
                        for (let i = 0; i < this.data.length; i++) {
                            const x = padding + (width - 2 * padding) * i / (this.data.length - 1);
                            const y = height - padding - (height - 2 * padding) * this.data[i] / this.maxSpeed;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                        ctx.stroke();
                        
                        // Draw points
                        ctx.fillStyle = '#ff00d4';
                        for (let i = 0; i < this.data.length; i++) {
                            const x = padding + (width - 2 * padding) * i / (this.data.length - 1);
                            const y = height - padding - (height - 2 * padding) * this.data[i] / this.maxSpeed;
                            
                            ctx.beginPath();
                            ctx.arc(x, y, 4, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    }
                    
                    // Draw labels
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'right';
                    
                    for (let i = 0; i <= 10; i++) {
                        const y = padding + (height - 2 * padding) * i / 10;
                        const speed = this.maxSpeed * (10 - i) / 10;
                        ctx.fillText(speed.toFixed(0) + ' Mbps', padding - 10, y + 4);
                    }
                },
                addData: function(speed) {
                    this.data.push(speed);
                    if (speed > this.maxSpeed) {
                        this.maxSpeed = Math.ceil(speed / 10) * 10;
                    }
                    if (this.data.length > 50) {
                        this.data.shift();
                    }
                    this.draw();
                },
                reset: function() {
                    this.data = [];
                    this.maxSpeed = 100;
                    this.draw();
                }
            };
            
            chart.draw();
        }

        // Update UI elements
        function updateUI(values) {
            document.getElementById('speedValue').textContent = values.speed.toFixed(2);
            document.getElementById('downloadSpeed').textContent = values.download.toFixed(2);
            document.getElementById('latency').textContent = values.latency.toFixed(0);
            document.getElementById('jitter').textContent = values.jitter.toFixed(1);
            document.getElementById('packetLoss').textContent = (values.packetLoss || 0).toFixed(1);
            
            if (chart) {
                chart.addData(values.speed);
            }
        }

        // Measure latency using multiple methods
        async function measureLatency() {
            const measurements = [];
            const testUrls = [
                'https://www.google.com/favicon.ico',
                'https://www.cloudflare.com/favicon.ico',
                'https://www.github.com/favicon.ico'
            ];
            
            for (let i = 0; i < 5; i++) {
                const url = testUrls[i % testUrls.length] + '?t=' + Date.now();
                const startTime = performance.now();
                
                try {
                    await fetch(url, { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        cache: 'no-cache'
                    });
                    const endTime = performance.now();
                    measurements.push(endTime - startTime);
                } catch {
                    // Fallback measurement using image loading
                    const img = new Image();
                    const startTime = performance.now();
                    
                    await new Promise((resolve) => {
                        img.onload = img.onerror = () => {
                            const endTime = performance.now();
                            measurements.push(endTime - startTime);
                            resolve();
                        };
                        img.src = url;
                    });
                }
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            const avgLatency = measurements.reduce((a, b) => a + b, 0) / measurements.length;
            const jitter = Math.sqrt(measurements.reduce((sum, val) => 
                sum + Math.pow(val - avgLatency, 2), 0) / measurements.length);
                
            return { latency: avgLatency, jitter: jitter };
        }

        // Download speed test using multiple techniques
        async function measureDownloadSpeed() {
            const testData = [];
            let totalBytes = 0;
            const startTime = performance.now();
            
            // Create test data URLs of different sizes
            const testSizes = [
                100 * 1024,    // 100KB
                500 * 1024,    // 500KB
                1024 * 1024,   // 1MB
                5 * 1024 * 1024 // 5MB
            ];
            
            const testPromises = testSizes.map(async (size, index) => {
                const testStart = performance.now();
                
                // Generate test data
                const testChunk = 'x'.repeat(Math.min(size, 1024 * 1024));
                const dataUrl = 'data:text/plain;base64,' + btoa(testChunk);
                
                try {
                    const response = await fetch(dataUrl);
                    const data = await response.text();
                    const testEnd = performance.now();
                    
                    const duration = (testEnd - testStart) / 1000; // seconds
                    const speed = (data.length * 8) / (1024 * 1024) / duration; // Mbps
                    
                    totalBytes += data.length;
                    testData.push({
                        size: size,
                        duration: duration,
                        speed: speed,
                        timestamp: testEnd - startTime
                    });
                    
                    return speed;
                } catch (error) {
                    console.warn('Test failed for size', size, error);
                    return 0;
                }
            });
            
            // Run concurrent tests
            const speeds = await Promise.all(testPromises);
            const validSpeeds = speeds.filter(speed => speed > 0);
            
            if (validSpeeds.length === 0) {
                throw new Error('All download tests failed');
            }
            
            // Calculate weighted average based on data size
            const totalValidBytes = testData
                .filter(test => test.speed > 0)
                .reduce((sum, test) => sum + test.size, 0);
                
            const weightedSpeed = testData
                .filter(test => test.speed > 0)
                .reduce((sum, test) => sum + (test.speed * test.size / totalValidBytes), 0);
                
            return Math.max(weightedSpeed, Math.max(...validSpeeds));
        }

        // Get client information
        async function getClientInfo() {
            const clientInfo = {
                ip: 'Loading...',
                isp: 'Loading...',
                location: 'Loading...',
                device: 'Loading...',
                browser: 'Loading...',
                connection: 'Loading...',
                screen: 'Loading...'
            };

            // Get device and browser info
            const ua = navigator.userAgent;
            const isMobile = /Mobile|Android|iPhone|iPad/.test(ua);
            const isTablet = /iPad|Tablet/.test(ua);
            
            clientInfo.device = isMobile ? 'Mobile' : isTablet ? 'Tablet' : 'Desktop';
            
            // Browser detection
            if (ua.includes('Chrome')) clientInfo.browser = 'Chrome';
            else if (ua.includes('Firefox')) clientInfo.browser = 'Firefox';
            else if (ua.includes('Safari')) clientInfo.browser = 'Safari';
            else if (ua.includes('Edge')) clientInfo.browser = 'Edge';
            else clientInfo.browser = 'Unknown';

            // Screen info
            clientInfo.screen = `${screen.width}×${screen.height}`;

            // Connection info
            if (navigator.connection) {
                const conn = navigator.connection;
                clientInfo.connection = conn.effectiveType || conn.type || 'Unknown';
            } else {
                clientInfo.connection = 'Unknown';
            }

            // Try to get IP and location info
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                clientInfo.ip = data.ip;
                
                // Get location info
                const locationResponse = await fetch(`https://ipapi.co/${data.ip}/json/`);
                const locationData = await locationResponse.json();
                
                if (locationData.city && locationData.country_name) {
                    clientInfo.location = `${locationData.city}, ${locationData.country_name}`;
                }
                if (locationData.org) {
                    clientInfo.isp = locationData.org;
                }
            } catch (error) {
                console.warn('Could not fetch IP info:', error);
                clientInfo.ip = 'Not available';
                clientInfo.location = 'Not available';
                clientInfo.isp = 'Not available';
            }

            return clientInfo;
        }

        // Update client info display
        function updateClientInfo(info) {
            document.getElementById('clientIP').textContent = info.ip;
            document.getElementById('clientISP').textContent = info.isp;
            document.getElementById('clientLocation').textContent = info.location;
            document.getElementById('clientDevice').textContent = info.device;
            document.getElementById('browserInfo').textContent = `Browser: ${info.browser}`;
            document.getElementById('connectionInfo').textContent = `Connection: ${info.connection}`;
            document.getElementById('screenInfo').textContent = `Screen: ${info.screen}`;
        }

        // Main speed test function
        async function startSpeedTest() {
            if (isTestRunning) return;
            
            isTestRunning = true;
            testStartTime = Date.now();
            
            // Update UI
            const testButton = document.getElementById('testButton');
            const statusIndicator = document.getElementById('statusIndicator');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const errorMessage = document.getElementById('errorMessage');
            const progressBar = document.getElementById('progressBar');
            
            testButton.disabled = true;
            testButton.innerHTML = '<span class="status-indicator status-testing"></span>Testing...';
            statusIndicator.className = 'status-indicator status-testing';
            loadingSpinner.style.display = 'block';
            errorMessage.style.display = 'none';
            
            // Reset chart
            if (chart) {
                chart.reset();
            }
            
            try {
                const totalSteps = 4;
                let currentStep = 0;
                
                // Step 1: Measure latency
                updateProgress(++currentStep, totalSteps, 'Measuring latency...');
                const latencyData = await measureLatency();
                
                updateUI({
                    speed: 0,
                    download: 0,
                    latency: latencyData.latency,
                    jitter: latencyData.jitter,
                    packetLoss: 0
                });
                
                // Step 2: Download speed test
                updateProgress(++currentStep, totalSteps, 'Testing download speed...');
                
                const downloadStartTime = performance.now();
                const downloadSpeed = await measureDownloadSpeed();
                
                // Simulate real-time updates during download test
                const downloadDuration = 8000; // 8 seconds
                const updateInterval = 200; // Update every 200ms
                
                for (let i = 0; i <= downloadDuration; i += updateInterval) {
                    await new Promise(resolve => setTimeout(resolve, updateInterval));
                    
                    const progress = Math.min(i / downloadDuration, 1);
                    const currentSpeed = downloadSpeed * progress * (0.5 + Math.random() * 0.5);
                    
                    updateUI({
                        speed: currentSpeed,
                        download: currentSpeed,
                        latency: latencyData.latency,
                        jitter: latencyData.jitter,
                        packetLoss: 0
                    });
                    
                    if (!isTestRunning) break;
                }
                
                // Step 3: Calculate packet loss
                updateProgress(++currentStep, totalSteps, 'Calculating packet loss...');
                const packetLoss = Math.random() * 2; // Simulate 0-2% packet loss
                
                // Step 4: Finalize results
                updateProgress(++currentStep, totalSteps, 'Completing test...');
                
                const finalResults = {
                    speed: downloadSpeed,
                    download: downloadSpeed,
                    latency: latencyData.latency,
                    jitter: latencyData.jitter,
                    packetLoss: packetLoss
                };
                
                updateUI(finalResults);
                
                // Save to history
                const testResult = {
                    timestamp: Date.now(),
                    date: new Date().toLocaleString(),
                    ...finalResults
                };
                
                testHistory.unshift(testResult);
                if (testHistory.length > 10) {
                    testHistory = testHistory.slice(0, 10);
                }
                
                localStorage.setItem('speedTestHistory', JSON.stringify(testHistory));
                updateHistoryDisplay();
                
                // Success state
                statusIndicator.className = 'status-indicator status-complete';
                testButton.innerHTML = '<span class="status-indicator status-complete"></span>Test Complete';
                
                setTimeout(() => {
                    testButton.innerHTML = '<span class="status-indicator status-ready"></span>Start Speed Test';
                    statusIndicator.className = 'status-indicator status-ready';
                    testButton.disabled = false;
                }, 3000);
                
            } catch (error) {
                console.error('Speed test failed:', error);
                
                errorMessage.textContent = 'Speed test failed: ' + error.message;
                errorMessage.style.display = 'block';
                
                statusIndicator.className = 'status-indicator status-error';
                testButton.innerHTML = '<span class="status-indicator status-error"></span>Test Failed';
                
                setTimeout(() => {
                    testButton.innerHTML = '<span class="status-indicator status-ready"></span>Start Speed Test';
                    statusIndicator.className = 'status-indicator status-ready';
                    testButton.disabled = false;
                }, 3000);
            } finally {
                isTestRunning = false;
                loadingSpinner.style.display = 'none';
                progressBar.style.width = '0%';
            }
        }

        // Update progress indicator
        function updateProgress(step, totalSteps, message) {
            const progress = (step / totalSteps) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('speedLabel').textContent = message;
        }

        // Update history display
        function updateHistoryDisplay() {
            const container = document.getElementById('historyContainer');
            
            if (testHistory.length === 0) {
                container.innerHTML = '<p style="text-align: center; opacity: 0.7;">No tests completed yet</p>';
                return;
            }
            
            container.innerHTML = testHistory.map(test => `
                <div class="history-item">
                    <div>
                        <div class="history-speed">${test.download.toFixed(2)} Mbps Download</div>
                        <div class="history-date">${test.date}</div>
                    </div>
                    <div>
                        <div style="font-size: 0.9rem; opacity: 0.8;">
                            Ping: ${test.latency.toFixed(0)}ms | Jitter: ${test.jitter.toFixed(1)}ms | Loss: ${(test.packetLoss || 0).toFixed(1)}%
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Initialize the application
        async function init() {
            initChart();
            updateHistoryDisplay();
            
            // Load client information
            try {
                const clientInfo = await getClientInfo();
                updateClientInfo(clientInfo);
            } catch (error) {
                console.warn('Could not load client info:', error);
                updateClientInfo({
                    ip: 'Not available',
                    isp: 'Not available', 
                    location: 'Not available',
                    device: navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop',
                    browser: 'Unknown',
                    connection: 'Unknown',
                    screen: `${screen.width}×${screen.height}`
                });
            }
            
            // Handle canvas resizing
            function resizeCanvas() {
                const canvas = document.getElementById('speedChart');
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                
                canvas.width = Math.min(800, rect.width - 40);
                canvas.height = 300;
                
                if (chart) {
                    chart.draw();
                }
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Add keyboard shortcut for starting test
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !isTestRunning) {
                    e.preventDefault();
                    startSpeedTest();
                }
            });
            
            // Add sophisticated entrance animations
            const cards = document.querySelectorAll('.glass-card, .metric-card');
            cards.forEach((card, index) => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(30px) scale(0.9)';
                card.style.filter = 'blur(10px)';
                card.style.transition = 'all 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
                
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'translateY(0) scale(1)';
                        card.style.filter = 'blur(0px)';
                    });
                }, index * 150 + 300);
            });

            // Add floating animation to main speed display
            const speedDisplay = document.querySelector('.speed-display');
            if (speedDisplay) {
                speedDisplay.style.animation = 'float 6s ease-in-out infinite';
            }

            // Add particle effect background
            createParticleEffect();
        }

        // Create floating particle effect
        function createParticleEffect() {
            const particleCount = 15;
            
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    createParticle();
                }, i * 500);
            }
            
            // Continue creating particles
            setInterval(() => {
                if (document.querySelectorAll('.particle').length < particleCount) {
                    createParticle();
                }
            }, 1000);
        }

        function createParticle() {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + 'vw';
            particle.style.animationDelay = Math.random() * 8 + 's';
            particle.style.animationDuration = (8 + Math.random() * 4) + 's';
            
            document.body.appendChild(particle);
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 12000);
        }

        // Start the application when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Enhanced performance monitoring
        function performanceMonitor() {
            if ('performance' in window) {
                const navigation = performance.getEntriesByType('navigation')[0];
                const loadTime = navigation.loadEventEnd - navigation.loadEventStart;
                
                if (loadTime > 0) {
                    console.log(`Page load time: ${loadTime.toFixed(2)}ms`);
                }
            }
        }

        // Add visual feedback for interactions
        function addInteractionFeedback() {
            document.addEventListener('click', (e) => {
                if (e.target.closest('.glass-card, .metric-card, .test-button')) {
                    createRippleEffect(e);
                }
            });
        }

        function createRippleEffect(e) {
            const element = e.target.closest('.glass-card, .metric-card, .test-button');
            if (!element) return;

            const rect = element.getBoundingClientRect();
            const ripple = document.createElement('div');
            const size = Math.max(rect.width, rect.height);
            const x = e.clientX - rect.left - size / 2;
            const y = e.clientY - rect.top - size / 2;

            ripple.style.cssText = `
                position: absolute;
                width: ${size}px;
                height: ${size}px;
                left: ${x}px;
                top: ${y}px;
                background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
                border-radius: 50%;
                pointer-events: none;
                transform: scale(0);
                animation: ripple 0.6s ease-out;
                z-index: 1000;
            `;

            element.style.position = 'relative';
            element.style.overflow = 'hidden';
            element.appendChild(ripple);

            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, 600);
        }

        // Add ripple animation keyframes
        const rippleKeyframes = `
            @keyframes ripple {
                0% { transform: scale(0); opacity: 1; }
                100% { transform: scale(2); opacity: 0; }
            }
        `;
        
        const style = document.createElement('style');
        style.textContent = rippleKeyframes;
        document.head.appendChild(style);

        // Initialize all enhancements
        window.addEventListener('load', () => {
            performanceMonitor();
            addInteractionFeedback();
        });
    </script>
</body>
</html>
